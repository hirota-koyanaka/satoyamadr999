# ログインアプリ 実装計画

## プロジェクト概要
名前・メールアドレス・パスワードで新規登録し、承認後にログインできるFlutterアプリケーション

## 技術スタック

### フロントエンド
- **Flutter** (Dart)
- **状態管理**: Provider または Riverpod
- **HTTP通信**: http または dio
- **ローカルストレージ**: shared_preferences (トークン保存用)
- **フォームバリデーション**: flutter_form_builder または 標準のTextFormField

### バックエンド
- **Django** (Python)
- **Django REST Framework**: REST API構築
- **データベース**: PostgreSQL または MySQL（SQLiteは開発環境のみ）
- **認証**: Django REST Framework Simple JWT または djangorestframework-simplejwt
- **メール送信**: Djangoのメール機能（SMTP）
- **CORS**: django-cors-headers（Flutterアプリからのアクセス許可）

### 管理者画面
- **Django Admin**: 承認画面の実装
- **カスタム管理画面**: Django Adminをカスタマイズして承認機能を実装

## 機能要件

### 1. 新規登録機能
- **画面**: 新規登録画面
- **入力項目**:
  - 名前（必須）
  - メールアドレス（必須・形式チェック）
  - パスワード（必須・最小8文字）
  - パスワード確認（必須・一致チェック）
- **処理フロー**:
  1. バリデーション実行
  2. バックエンドAPIに登録リクエスト送信
  3. ユーザー情報をDBに保存（承認状態: pending）
  4. 管理者に承認依頼通知（オプション）
  5. ユーザーに「承認待ち」メッセージ表示

### 2. 承認フロー
- **管理者側**（Django Admin画面で実装）:
  - Django Adminで承認待ちユーザー一覧を表示
  - ユーザーの承認/拒否機能
  - 承認時にメール通知を自動送信
  - 承認状態のフィルタリング機能
- **ユーザー側**:
  - 承認待ち状態の表示（オプション）
  - ログイン時に承認状態をチェック

### 3. メール通知機能
- **承認完了時**:
  - ユーザーのメールアドレスに承認通知を送信
  - メール内容: 「アカウントが承認されました。ログインできます。」

### 4. ログイン機能
- **画面**: ログイン画面
- **入力項目**:
  - メールアドレス（必須）
  - パスワード（必須）
- **処理フロー**:
  1. バリデーション実行
  2. バックエンドAPIにログインリクエスト送信
  3. 承認状態をチェック（承認済みのみログイン可能）
  4. 認証トークンをローカルに保存
  5. ホーム画面に遷移

### 5. ホーム画面
- **表示内容**:
  - 登録した名前を表示
  - ログアウトボタン
- **認証状態チェック**:
  - トークンが有効か確認
  - 無効な場合はログイン画面にリダイレクト

## プロジェクト構造

### Flutterアプリ
```
ログインアプリ/
├── lib/
│   ├── main.dart
│   ├── models/
│   │   ├── user.dart
│   │   └── auth_response.dart
│   ├── services/
│   │   ├── auth_service.dart
│   │   ├── api_service.dart
│   │   └── storage_service.dart
│   ├── providers/
│   │   └── auth_provider.dart
│   ├── screens/
│   │   ├── register_screen.dart
│   │   ├── login_screen.dart
│   │   └── home_screen.dart
│   ├── widgets/
│   │   ├── custom_text_field.dart
│   │   └── loading_indicator.dart
│   └── utils/
│       ├── validators.dart
│       └── constants.dart
├── pubspec.yaml
└── README.md
```

### Djangoバックエンド
```
backend/
├── manage.py
├── backend/
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── accounts/  # 認証アプリ
│   ├── __init__.py
│   ├── models.py          # Userモデル
│   ├── serializers.py     # DRFシリアライザー
│   ├── views.py           # APIビュー
│   ├── admin.py           # 承認画面のカスタマイズ
│   ├── urls.py            # APIルーティング
│   ├── permissions.py     # カスタムパーミッション
│   └── signals.py         # 承認時のメール送信シグナル
├── requirements.txt
└── README.md
```

## 実装ステップ

### Phase 1: Djangoバックエンドのセットアップ
1. Djangoプロジェクトの作成
2. 仮想環境のセットアップ
3. 必要なパッケージのインストール
   - Django
   - djangorestframework
   - djangorestframework-simplejwt
   - django-cors-headers
   - psycopg2 (PostgreSQL使用時)
4. データベースの設定（PostgreSQL推奨）
5. accountsアプリの作成

### Phase 2: Djangoモデル・API実装
1. **Userモデルの作成**
   - カスタムUserモデル（AbstractUserを継承）
   - 承認状態フィールド（status）
   - タイムスタンプフィールド

2. **シリアライザーの実装**
   - UserSerializer
   - RegisterSerializer
   - LoginSerializer

3. **APIビューの実装**
   - POST /api/register (新規登録)
   - POST /api/login (ログイン・JWTトークン発行)
   - GET /api/user (ユーザー情報取得)
   - カスタムパーミッションの実装

4. **URLルーティングの設定**
   - APIエンドポイントの設定
   - JWT認証の設定

5. **メール通知機能の実装**
   - Djangoのメール設定
   - シグナルを使用した承認時のメール送信

### Phase 3: Django Admin承認画面の実装
1. **Admin画面のカスタマイズ**
   - UserAdminのカスタマイズ
   - 承認待ちユーザーのフィルタリング
   - 一括承認機能の実装
   - 承認/拒否アクションの追加

2. **承認機能の実装**
   - 承認ボタンの追加
   - 承認時の処理（ステータス更新・メール送信）
   - 拒否機能の実装

### Phase 4: Flutterアプリのセットアップ
1. Flutterプロジェクトの作成
2. 必要なパッケージのインストール
3. プロジェクト構造の作成

### Phase 5: Flutterアプリの実装
1. **モデルクラスの作成**
   - Userモデル
   - AuthResponseモデル

2. **サービス層の実装**
   - API通信サービス（Django APIとの連携）
   - 認証サービス
   - ローカルストレージサービス（JWTトークン保存）

3. **状態管理の実装**
   - 認証状態の管理
   - ローディング状態の管理

4. **UI実装**
   - 新規登録画面
   - ログイン画面
   - ホーム画面（名前表示）
   - 共通ウィジェット（テキストフィールド、ボタンなど）

5. **ルーティング設定**
   - 画面遷移の管理
   - 認証ガードの実装

### Phase 6: 統合・テスト
1. CORS設定の確認
2. エラーハンドリングの実装
3. バリデーションの実装
4. ローディング状態の表示
5. エンドツーエンドテストの実行

## データベーススキーマ（Djangoモデル）

### User モデル（AbstractUserを継承）
```python
class User(AbstractUser):
    STATUS_CHOICES = [
        ('pending', '承認待ち'),
        ('approved', '承認済み'),
        ('rejected', '拒否'),
    ]
    
    # 既存フィールド: username, email, password, first_name, last_name等
    status = CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    created_at = DateTimeField(auto_now_add=True)
    approved_at = DateTimeField(null=True, blank=True)
    approved_by = ForeignKey('self', null=True, blank=True, on_delete=SET_NULL)
    
    # emailをユーザー名として使用
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['first_name']  # first_nameを名前として使用
```

### マイグレーション
- `python manage.py makemigrations`
- `python manage.py migrate`

## API仕様（Django REST Framework）

### 1. 新規登録
```
POST /api/accounts/register/
Content-Type: application/json

Request Body:
{
  "first_name": "太郎",
  "last_name": "山田",
  "email": "yamada@example.com",
  "password": "password123",
  "password_confirm": "password123"
}

Response (成功: 200):
{
  "success": true,
  "message": "登録申請を受け付けました。承認をお待ちください。",
  "user": {
    "id": 1,
    "email": "yamada@example.com",
    "first_name": "太郎",
    "last_name": "山田",
    "status": "pending"
  }
}

Response (エラー: 400):
{
  "email": ["このメールアドレスは既に登録されています。"],
  "password": ["パスワードが一致しません。"]
}
```

### 2. ログイン（JWT認証）
```
POST /api/accounts/login/
Content-Type: application/json

Request Body:
{
  "email": "yamada@example.com",
  "password": "password123"
}

Response (成功: 200):
{
  "access": "eyJ0eXAiOiJKV1QiLCJhbGc...",
  "refresh": "eyJ0eXAiOiJKV1QiLCJhbGc...",
  "user": {
    "id": 1,
    "email": "yamada@example.com",
    "first_name": "太郎",
    "last_name": "山田",
    "full_name": "山田 太郎"
  }
}

Response (承認待ち: 403):
{
  "detail": "アカウントがまだ承認されていません。管理者の承認をお待ちください。"
}

Response (認証失敗: 401):
{
  "detail": "メールアドレスまたはパスワードが正しくありません。"
}
```

### 3. ユーザー情報取得
```
GET /api/accounts/user/
Headers:
  Authorization: Bearer {access_token}

Response (成功: 200):
{
  "id": 1,
  "email": "yamada@example.com",
  "first_name": "太郎",
  "last_name": "山田",
  "full_name": "山田 太郎",
  "status": "approved"
}

Response (認証失敗: 401):
{
  "detail": "認証情報が提供されていません。"
}
```

### 4. トークンリフレッシュ
```
POST /api/accounts/token/refresh/
Content-Type: application/json

Request Body:
{
  "refresh": "eyJ0eXAiOiJKV1QiLCJhbGc..."
}

Response (成功: 200):
{
  "access": "eyJ0eXAiOiJKV1QiLCJhbGc..."
}
```

## セキュリティ考慮事項

### Django側
1. **パスワードハッシュ化**: DjangoのデフォルトのPBKDF2（またはArgon2）を使用
2. **HTTPS通信**: 本番環境では必ずHTTPSを使用
3. **JWTトークンの設定**:
   - アクセストークンの有効期限: 15分〜1時間
   - リフレッシュトークンの有効期限: 7日〜30日
4. **CORS設定**: 許可するオリジンを適切に設定
5. **CSRF保護**: DjangoのCSRF保護を有効化（APIではJWT認証で回避）
6. **レート制限**: django-ratelimitを使用してブルートフォース攻撃対策
7. **入力値のバリデーション**: DRFシリアライザーで実装
8. **SQLインジェクション対策**: Django ORMを使用（自動対策）
9. **セキュリティ設定**: settings.pyで適切なSECRET_KEY、DEBUG=False等を設定

### Flutter側
1. **トークンの安全な保存**: shared_preferencesで暗号化して保存（推奨: flutter_secure_storage）
2. **HTTPS通信**: API通信は必ずHTTPSを使用
3. **入力値のバリデーション**: クライアント側でも実装
4. **エラーメッセージ**: 詳細なエラー情報をユーザーに表示しない

## 推奨パッケージ

### Django（requirements.txt）
```txt
Django==4.2.7
djangorestframework==3.14.0
djangorestframework-simplejwt==5.3.0
django-cors-headers==4.3.1
psycopg2-binary==2.9.9  # PostgreSQL使用時
python-decouple==3.8  # 環境変数管理
Pillow==10.1.0  # 画像処理（必要に応じて）
```

### Flutter（pubspec.yaml）
```yaml
dependencies:
  flutter:
    sdk: flutter
  provider: ^6.1.1
  http: ^1.1.0
  shared_preferences: ^2.2.2
  flutter_secure_storage: ^9.0.0  # トークンの安全な保存
  flutter_form_builder: ^9.1.1
  form_builder_validators: ^9.1.0
  intl: ^0.19.0
```

## Django設定のポイント

### settings.py の主要設定
```python
# CORS設定
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",  # Flutter開発時
    "http://127.0.0.1:3000",
]

# JWT設定
from datetime import timedelta
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True,
}

# メール設定
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'  # Gmail使用時
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = 'your-email@gmail.com'
EMAIL_HOST_PASSWORD = 'your-app-password'
```

## Django Admin承認画面の実装詳細

### admin.py の実装例
```python
from django.contrib import admin
from django.core.mail import send_mail
from django.conf import settings
from .models import User

@admin.action(description='選択したユーザーを承認する')
def approve_users(modeladmin, request, queryset):
    for user in queryset:
        if user.status == 'pending':
            user.status = 'approved'
            user.approved_at = timezone.now()
            user.approved_by = request.user
            user.save()
            
            # メール送信
            send_mail(
                subject='アカウント承認のお知らせ',
                message=f'{user.get_full_name()}様\n\nアカウントが承認されました。ログインできます。',
                from_email=settings.EMAIL_HOST_USER,
                recipient_list=[user.email],
                fail_silently=False,
            )
    modeladmin.message_user(request, f'{queryset.count()}件のユーザーを承認しました。')

class UserAdmin(admin.ModelAdmin):
    list_display = ('email', 'get_full_name', 'status', 'created_at', 'approved_at')
    list_filter = ('status', 'created_at')
    search_fields = ('email', 'first_name', 'last_name')
    actions = [approve_users]
    
    def get_full_name(self, obj):
        return obj.get_full_name()
    get_full_name.short_description = '名前'
```

## 実装状況

### 完了した項目
- ✅ Djangoプロジェクトの作成とセットアップ
- ✅ UserモデルとAPIの実装
- ✅ Django Admin承認画面の実装
- ✅ Flutterプロジェクトの作成
- ✅ FlutterアプリとDjango APIの統合
- ✅ エラーハンドリングの改善（401、403エラーの適切な処理）
- ✅ API通信時の自動トークンリフレッシュ機能
- ✅ エラーメッセージの統一と改善

### 次のステップ
1. エンドツーエンドテストの実行
2. デプロイ準備
3. パフォーマンス最適化（必要に応じて）
4. セキュリティ監査（必要に応じて）

